### 🧠 What is SSH?

**SSH** stands for **Secure Shell** — it's a protocol that allows you to **safely connect to another computer over a network**, usually to a **remote Linux server**, using **encryption**.

---

### 🔐 Why SSH?

* Secure login over internet
* Encrypted communication
* Commonly used by DevOps, developers, sysadmins

---

### 💻 How to Login to SSH (From Linux/Windows Terminal)

```bash
ssh username@hostname_or_ip
```

#### 📌 Example:

```bash
ssh mounisha@192.168.1.10
```

* `mounisha` → your username on the remote system
* `192.168.1.10` → IP address of the server

> It will ask for your **password** (unless you use SSH key-based login).

---

### 🔑 With SSH Key (No Password Prompt):

```bash
ssh -i /path/to/private_key.pem username@hostname
```

---

### 🧪 Test it (if you have local server or use services like GitHub):

```bash
ssh localhost
```

or

```bash
ssh user@your_vm_public_ip
```

---

### 🛠️ Common SSH Flags:

| Flag | Description                                |
| ---- | ------------------------------------------ |
| `-i` | Identity file (private key)                |
| `-p` | Specify port number                        |
| `-v` | Verbose mode (debugging connection issues) |
| `-X` | Enable X11 forwarding (GUI over SSH)       |
| `-L` | Port forwarding (local)                    |

---
### `du .` – Command Explained Simply

The `du` command in Linux is used to **estimate file space usage**.
When you run:

```bash
du .
```

### 🔍 What it Does:

* `du` = **disk usage**
* `.` = **current directory**

This command shows you how much space each file/folder inside the **current directory** is using.

---

### 🧾 Example:

Suppose you're inside a folder `/home/mounisha/Projects`, and you run:

```bash
du .
```

You might see output like:

```
4       ./docs
20      ./src
2       ./tests
28      .
```

### ✅ Meaning:

* `./docs` is using 4 KB
* `./src` is using 20 KB
* `./tests` is using 2 KB
* Total space used in this directory: 28 KB

---

### 🔧 Useful Flags:

| Flag            | What it Does                  | Example               |
| --------------- | ----------------------------- | --------------------- |
| `-h`            | Human-readable (KB/MB/GB)     | `du -h .`             |
| `-s`            | Summary only (total size)     | `du -sh .`            |
| `--max-depth=N` | Limit folder depth shown      | `du -h --max-depth=1` |
| `-a`            | Show files as well as folders | `du -ah .`            |

---

### 🧠 `ps` Command in Linux – **Process Status**

The `ps` (process status) command is used to **display information about active processes** on a Linux system.

---

### 📌 Basic Usage:

```bash
ps
```

Shows **only your current shell’s** processes.

---

### 🧪 Example:

```bash
ps
```

Output:

```
  PID TTY          TIME CMD
 1234 pts/0    00:00:00 bash
 1256 pts/0    00:00:00 ps
```

* `PID`: Process ID
* `TTY`: Terminal type
* `TIME`: CPU time used
* `CMD`: Command name

---

### 🔧 Commonly Used Flags:

| Command           | Meaning                                                     |
| ----------------- | ----------------------------------------------------------- |
| `ps -e`           | Show **all processes**                                      |
| `ps -f`           | Show **full format listing**                                |
| `ps -ef`          | Show **all processes with full format** (most common)       |
| `ps -u username`  | Show processes of a specific user                           |
| `ps aux`          | Show **detailed info** (BSD style) of all running processes |
| `ps -p <PID>`     | Show details of a **specific process ID**                   |
| `ps --sort=-%mem` | Sort processes by **highest memory usage**                  |
| `ps --sort=-%cpu` | Sort processes by **highest CPU usage**                     |

---

### 🔍 Example with `ps -ef`:

```bash
ps -ef
```

Output:

```
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Aug06 ?        00:00:03 /sbin/init
mounisha  1234  1200  0 10:00 pts/0    00:00:00 bash
mounisha  1301  1234  0 10:02 pts/0    00:00:00 ps -ef
```

---

### 💡 Tip:

You can combine with `grep` to find specific processes:

```bash
ps -ef | grep firefox
```

### 🧠 `top` Command in Linux – **Live Process Monitoring Tool**

The `top` command shows a **real-time, dynamic view** of the system’s running processes, CPU usage, memory consumption, and more.

---

### ✅ Basic Usage:

```bash
top
```

It opens an **interactive interface** that updates every few seconds, showing processes in order of resource usage (usually by CPU).

---

### 📌 Key Sections Explained:

| Section                                                           | Description                                               |
| ----------------------------------------------------------------- | --------------------------------------------------------- |
| `top - 10:30:01 up 2:00, 2 users, load average: 0.45, 0.34, 0.22` | System uptime, users, load averages                       |
| `Tasks:`                                                          | Shows total, running, sleeping, stopped, zombie processes |
| `%Cpu(s):`                                                        | CPU usage breakdown: user space, system, idle, etc.       |
| `KiB Mem:` / `MiB Mem:`                                           | Memory usage: total, used, free, buffers                  |
| `KiB Swap:`                                                       | Swap memory usage                                         |
| Process Table                                                     | Shows PID, USER, %CPU, %MEM, TIME+, COMMAND, etc.         |

---

### 🎮 Interactive Keys:

| Key         | Action                            |
| ----------- | --------------------------------- |
| `q`         | Quit                              |
| `P`         | Sort by CPU usage                 |
| `M`         | Sort by memory usage              |
| `k`         | Kill a process (you'll enter PID) |
| `r`         | Renice a process                  |
| `h`         | Help                              |
| `Shift + >` | Next sort field                   |
| `Shift + <` | Previous sort field               |

---

### 🔧 Common Flags:

| Command             | Description                               |
| ------------------- | ----------------------------------------- |
| `top -u <username>` | Show processes only for that user         |
| `top -p <PID>`      | Show only a specific process              |
| `top -n 1`          | Run once and exit (useful for scripts)    |
| `top -b`            | Batch mode (non-interactive), for logging |

---

### 🧪 Simple Example:

```bash
top -u mounisha
```

Shows only processes by the user `mounisha`.

---

### 🔥 Pro Tip:

To **log top output** to a file:

```bash
top -b -n 1 > top_report.txt
```

Here’s a **simple and clear explanation** on how to **use `fuser` and `kill`** to terminate processes in Linux:

---

### 🧰 Example: Find and Kill Process Using a File or Port

Let’s say:

* A **file** is being used and you want to close it.
* Or a **port** (like `8080`) is in use and blocking your app.

---

### 🔍 1. **Find the Process Using `fuser`**

#### 👉 For a file:

```bash
fuser filename
```

#### 👉 For a port:

```bash
fuser -n tcp 8080
```

This shows the **PID** (process ID) using that resource.

---

### 🔪 2. **Kill the Process Using `fuser -k`**

#### ✅ One-liner (kills the process on TCP port 8080):

```bash
fuser -k -n tcp 8080
```

#### ✅ Kill process using a file:

```bash
fuser -k filename
```

This sends the default **SIGKILL (signal 9)** to stop it immediately.

---

### 🛑 Safer Option (ask before killing):

```bash
fuser -ki -n tcp 8080
```

The `-i` asks for confirmation before killing each process.

---

### 🧠 Extra: Use `kill` manually if you have PID

```bash
kill <PID>
```

Force kill if needed:

```bash
kill -9 <PID>
```

---

### 🧾 Summary:

| Command                | Purpose                       |
| ---------------------- | ----------------------------- |
| `fuser filename`       | Find process using a file     |
| `fuser -n tcp 8080`    | Find process using port 8080  |
| `fuser -k filename`    | Kill process using the file   |
| `fuser -k -n tcp 8080` | Kill process using the port   |
| `kill -9 PID`          | Force kill a specific process |

---

Here’s a **simple explanation** of the `free` command in Linux:

---

### 🧠 **What is `free`?**

The `free` command shows the **amount of memory** (RAM) and **swap** space being used and available in your Linux system.

---

### 📌 **Basic Command**

```bash
free
```

This displays memory in **kilobytes (KB)** by default.

---

### 📊 **Example Output**

```bash
              total        used        free      shared  buff/cache   available
Mem:        8026056     2154328     1507636      123456     4364092     5492012
Swap:       2097148      104856     1992292
```

---

### 🏷️ **Useful Flags**

| Flag       | Description                          | Example        |
| ---------- | ------------------------------------ | -------------- |
| `-h`       | Human-readable (MB, GB)              | `free -h`      |
| `-m`       | Show output in MB                    | `free -m`      |
| `-g`       | Show output in GB                    | `free -g`      |
| `-t`       | Show **total** of RAM + swap         | `free -h -t`   |
| `-s <sec>` | Refresh output every `<sec>` seconds | `free -h -s 2` |

---

### 💡 **Most Common Usage**

```bash
free -h
```

→ Shows memory in easy-to-read format like `2.1G`, `512M`, etc.

---

Let me know if you want to **add this to your README.md file** or want a comparison with `top`, `vmstat`, or `htop`.
Here’s a **simple explanation** of the `nohup` command in Linux with examples:

---

## 🧠 What is `nohup`?

**`nohup`** stands for **"no hang up"**.
It lets you run a command **in the background** even **after you log out** or **close the terminal**.

---

## ✅ When to Use

Use `nohup` when:

* You want a long-running script or command to **continue running after logout**
* You want to run something **in the background** without interruption

---

## 🧪 Basic Syntax

```bash
nohup <command> &
```

---

## 📂 Example

Let's say you want to run a Python script:

```bash
nohup python3 myscript.py &
```

This will:

* Start `myscript.py` in the background
* Keep it running even if you log out
* Save output to `nohup.out` file by default

---

## 📁 Where is the Output?

By default, `nohup` writes all output to:

```bash
nohup.out
```

You can also redirect it:

```bash
nohup python3 myscript.py > output.log 2>&1 &
```

* `> output.log` → saves standard output
* `2>&1` → redirects error output to the same file

---

## 🚀 How to Check It’s Running?

Use:

```bash
ps aux | grep myscript.py
```

Or:

```bash
jobs -l
```

---

## 🛑 How to Stop It?

Get the PID (Process ID) using `ps` or `jobs`, then:

```bash
kill <PID>
```

---

Let me know if you want this added to your README or combined with other Linux command explanations.
Here’s a **simple explanation** of the `vmstat` command in Linux, with examples:

---

## 🧠 What is `vmstat`?

**`vmstat`** stands for **Virtual Memory Statistics**.
It shows you important system information like:

* CPU usage
* Memory (RAM) usage
* Swap usage
* I/O performance
* Process info

It helps **monitor system performance** in real time.

---

## ✅ Basic Syntax

```bash
vmstat [delay] [count]
```

* `delay` = time in seconds between updates
* `count` = number of updates to display

---

## 🧪 Examples

### ➤ Show system performance **once**

```bash
vmstat
```

### ➤ Show updates **every 2 seconds**, 5 times

```bash
vmstat 2 5
```

This displays stats every 2 seconds, for 5 times.

---

## 🔍 Sample Output Explanation

```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0  12000   1024  30000    0    0     1     0  100  150  2  1 96  1  0
```

| Column      | Meaning                                     |
| ----------- | ------------------------------------------- |
| `r`         | # of processes waiting to run (ready queue) |
| `b`         | # of processes in uninterruptible sleep     |
| `swpd`      | Virtual memory used (swap)                  |
| `free`      | Free memory                                 |
| `buff`      | Buffers                                     |
| `cache`     | Cached files                                |
| `si` / `so` | Swap in / swap out                          |
| `bi` / `bo` | Blocks received/sent to disk                |
| `in`        | Interrupts per second                       |
| `cs`        | Context switches per second                 |
| `us`        | User CPU usage (%)                          |
| `sy`        | System CPU usage (%)                        |
| `id`        | Idle CPU (%)                                |
| `wa`        | Time waiting for I/O (%)                    |
| `st`        | Time stolen from VM (hypervisor overhead)   |

---

## 🛠️ Use Case

You can use `vmstat` to:

* Check if memory is full
* Monitor CPU usage
* Detect swapping (slow systems)
* Investigate performance issues

---




Would you like a simple **diagram** or a **practice setup using Vagrant** for SSH?
