Alright — here’s a **detailed but beginner-friendly explanation** of **awk, sed, and grep** that even someone with 2 years of Linux administration experience should understand well.

---

## 1️⃣ **grep** — *Search for text patterns in files*

**Purpose:**

* `grep` searches text for patterns (using plain text or regular expressions).
* It prints only the matching lines.

**Syntax:**

```bash
grep [options] "pattern" file
```

**Common Options:**

| Option | Meaning                                  |
| ------ | ---------------------------------------- |
| `-i`   | Case-insensitive search                  |
| `-v`   | Invert match (show lines *not* matching) |
| `-n`   | Show line numbers                        |
| `-r`   | Search recursively in directories        |
| `-E`   | Use extended regex (same as `egrep`)     |

**Examples:**

```bash
grep "error" logfile.txt           # Search for 'error'
grep -i "error" logfile.txt        # Search for 'error' (case-insensitive)
grep -v "success" logfile.txt      # Show lines without 'success'
grep -rn "error" /var/log          # Search 'error' recursively with line numbers
```

**Sample Output:**

```
12:Error: Connection failed
45:Error: File not found
```

---

## 2️⃣ **sed** — *Stream Editor (Find, Replace, Modify)*

**Purpose:**

* `sed` edits text **in a stream** (input from file or pipe) without opening an editor.
* Often used for search/replace, delete lines, insert lines, etc.

**Syntax:**

```bash
sed [options] 'command' file
```

**Common Commands:**

| Command                  | Action                              |
| ------------------------ | ----------------------------------- |
| `s/pattern/replacement/` | Substitute pattern with replacement |
| `g`                      | Global replacement in the line      |
| `-i`                     | Edit file **in place**              |
| `/pattern/d`             | Delete lines matching pattern       |
| `n`                      | Print specific line number          |

**Examples:**

```bash
sed 's/error/warning/' logfile.txt          # Replace first 'error' with 'warning'
sed 's/error/warning/g' logfile.txt         # Replace all 'error' with 'warning'
sed -i 's/error/warning/g' logfile.txt      # Replace in file directly
sed '/DEBUG/d' logfile.txt                  # Delete lines containing 'DEBUG'
sed -n '5p' logfile.txt                     # Print only 5th line
```

**Sample Output (before → after):**

```
Before: Error: Connection failed
After:  Warning: Connection failed
```

---

## 3️⃣ **awk** — *Data extraction and reporting tool*

**Purpose:**

* `awk` processes text **column by column**.
* Useful for logs, CSV, and reports.

**Syntax:**

```bash
awk 'pattern { action }' file
```

**Key Points:**

* `$1`, `$2`, … represent **columns** (fields) in a line.
* `$0` means the **whole line**.
* `FS` is Field Separator (default: whitespace).

**Common Uses:**

| Task                   | Command                                  |
| ---------------------- | ---------------------------------------- |
| Print specific column  | `awk '{print $1}' file`                  |
| Print multiple columns | `awk '{print $1, $3}' file`              |
| Filter by value        | `awk '$2 > 100 {print $1, $2}' file`     |
| Change field separator | `awk -F, '{print $1}' file.csv`          |
| Add column sum         | `awk '{sum += $2} END {print sum}' file` |

**Examples:**

```bash
awk '{print $1, $3}' logfile.txt         # Show column 1 & 3
awk -F: '{print $1}' /etc/passwd         # Print usernames (first field before :)
awk '$3 > 1000 {print $1, $3}' /etc/passwd  # Filter by UID > 1000
```

**Sample Output:**

```
root 0
mounisha 1001
```

---

✅ **Quick Comparison Table**

| Tool   | Works On                  | Main Purpose                   | Example                        |
| ------ | ------------------------- | ------------------------------ | ------------------------------ |
| `grep` | Text (lines)              | Search/filter lines by pattern | `grep "error" file`            |
| `sed`  | Text (lines)              | Modify/replace/delete text     | `sed 's/error/warning/g' file` |
| `awk`  | Structured text (columns) | Process, analyze, format       | `awk '{print $1, $3}' file`    |

---
Alright — let’s go through **`awk`**, **`sed`**, and **`grep`** with **detailed real-time examples** so you can *see exactly how each works in practice*.
I’ll explain them like I’m walking you through a Linux terminal session.

---

## **1️⃣ grep – Search for text patterns in files**

**Think of it as a "find words inside files" tool.**

**Syntax:**

```bash
grep [OPTIONS] PATTERN [FILE...]
```

**Common Examples:**

| Command                             | What It Does                                         | Output Example                       |
| ----------------------------------- | ---------------------------------------------------- | ------------------------------------ |
| `grep "error" logfile.txt`          | Finds lines containing `"error"` in `logfile.txt`.   | `2025-08-13 12:21: Error: Disk full` |
| `grep -i "error" logfile.txt`       | Case-insensitive search (`error`, `Error`, `ERROR`). | `Error` and `ERROR` both matched     |
| `grep -n "error" logfile.txt`       | Shows **line numbers** where matches are found.      | `42: Error: Disk full`               |
| `grep -r "TODO" /home/user/project` | Recursively search through all files in a folder.    | Shows all `TODO` comments            |
| `grep -v "DEBUG" logfile.txt`       | Shows lines **without** the word DEBUG.              | Removes debug log lines              |

---

## **2️⃣ sed – Stream editor (find/replace/edit text in files)**

**Think of it as "search and replace on steroids".**

**Syntax:**

```bash
sed [OPTIONS] 's/pattern/replacement/flags' [FILE]
```

**Common Examples:**

| Command                                  | What It Does                                                          | Output Example          |
| ---------------------------------------- | --------------------------------------------------------------------- | ----------------------- |
| `sed 's/error/warning/' logfile.txt`     | Replaces **first occurrence** of "error" in each line with "warning". | `"warning: Disk full"`  |
| `sed 's/error/warning/g' logfile.txt`    | Replaces **all occurrences** in each line.                            | All `error` → `warning` |
| `sed -i 's/error/warning/g' logfile.txt` | Edit file **in-place**.                                               | File updated directly   |
| `sed -n '5,10p' logfile.txt`             | Prints only lines 5–10.                                               | Shows selected lines    |
| `sed '/DEBUG/d' logfile.txt`             | Deletes lines containing `DEBUG`.                                     | All debug lines removed |

---

## **3️⃣ awk – Field-based text processing**

**Think of it as "Excel for your terminal".**
It splits each line into **columns (fields)** and lets you process them.

**Syntax:**

```bash
awk 'pattern { action }' file
```

**Common Examples:**

| Command                                       | What It Does                             | Output Example           |
| --------------------------------------------- | ---------------------------------------- | ------------------------ |
| `awk '{print $1}' logfile.txt`                | Prints **first column** of each line.    | `2025-08-13`             |
| `awk '{print $1, $3}' logfile.txt`            | Prints columns 1 and 3.                  | `2025-08-13 Disk`        |
| `awk -F: '{print $1}' /etc/passwd`            | Uses `:` as delimiter; prints usernames. | `root`, `user1`, `admin` |
| `awk '$3 > 1000 {print $1, $3}' /etc/passwd`  | Print rows where **3rd column > 1000**.  | Shows normal users only  |
| `awk '{sum += $2} END {print sum}' sales.txt` | Sum the **second column** values.        | `Total: 4500`            |

---

## 🔹 **Real-Time Combined Example**

Let’s say we have a log file:

```text
2025-08-13 10:12:33 INFO User admin logged in
2025-08-13 10:15:42 ERROR Disk full
2025-08-13 10:18:59 WARNING CPU usage high
2025-08-13 10:20:01 INFO User guest logged out
```

| Tool     | Example                                | Result                                      |
| -------- | -------------------------------------- | ------------------------------------------- |
| **grep** | `grep "ERROR" logfile.txt`             | `2025-08-13 10:15:42 ERROR Disk full`       |
| **sed**  | `sed 's/ERROR/CRITICAL/' logfile.txt`  | Changes ERROR → CRITICAL                    |
| **awk**  | `awk '{print $1, $2, $3}' logfile.txt` | Shows first 3 columns (date + time + level) |

---

Alright — here’s a **combined, detailed guide** for **`awk`**, **`sed`**, and **`grep`** with **real-time examples** so you can clearly see the differences and when to use each.

---

## **1. `grep` – Search for Patterns in Text**

**Purpose:** Find matching lines in a file or command output based on a pattern.

**Syntax:**

```bash
grep [options] "pattern" filename
```

**Common Options:**

| Option | Meaning                                         |
| ------ | ----------------------------------------------- |
| `-i`   | Case-insensitive search                         |
| `-n`   | Show line numbers                               |
| `-v`   | Invert match (show lines that do **not** match) |
| `-r`   | Recursive search in directories                 |
| `-E`   | Use extended regex                              |

**Examples:**

```bash
# Find all lines containing "error" in a log file
grep "error" /var/log/syslog

# Case-insensitive search for 'mounisha' in file.txt
grep -i "mounisha" file.txt

# Show line numbers where 'failed' appears
grep -n "failed" /var/log/auth.log

# Search recursively for 'TODO' in code folder
grep -r "TODO" ~/projects/
```

---

## **2. `sed` – Stream Editor (Find & Replace, Edit Text)**

**Purpose:** Edit or transform text in a file or stream without opening it in an editor.

**Syntax:**

```bash
sed [options] 'command' filename
```

**Common Commands:**

| Command                  | Meaning               |
| ------------------------ | --------------------- |
| `s/pattern/replacement/` | Substitute text       |
| `-i`                     | Edit file in-place    |
| `d`                      | Delete matching lines |
| `p`                      | Print matching lines  |

**Examples:**

```bash
# Replace 'apple' with 'orange' in file.txt (show output only)
sed 's/apple/orange/' file.txt

# Replace all occurrences of 'foo' with 'bar' in file.txt (edit in place)
sed -i 's/foo/bar/g' file.txt

# Delete all lines containing 'test'
sed '/test/d' file.txt

# Replace '2024' with '2025' only on lines containing 'Year:'
sed '/Year:/s/2024/2025/' file.txt
```

---

## **3. `awk` – Text Processing & Field Extraction**

**Purpose:** Process structured text (like CSV, logs) and extract or calculate data based on patterns.

**Syntax:**

```bash
awk 'pattern { action }' filename
```

**Common Built-in Variables:**

| Variable      | Meaning                          |
| ------------- | -------------------------------- |
| `$1, $2, ...` | Fields in each line              |
| `NF`          | Number of fields                 |
| `NR`          | Current line number              |
| `FS`          | Field separator (default: space) |

**Examples:**

```bash
# Print the first column of a file
awk '{print $1}' file.txt

# Print first and third columns separated by a comma
awk '{print $1 "," $3}' file.txt

# Print lines where second column > 100
awk '$2 > 100' data.txt

# Change field separator to comma and print second column
awk -F, '{print $2}' data.csv

# Sum of second column
awk '{sum += $2} END {print sum}' data.txt
```

---

## **Quick Comparison Table**

| Feature          | `grep` | `sed` | `awk` |
| ---------------- | ------ | ----- | ----- |
| Search only      | ✅      | ✅     | ✅     |
| Replace text     | ❌      | ✅     | ✅     |
| Field extraction | ❌      | ❌     | ✅     |
| Calculations     | ❌      | ❌     | ✅     |
| Works on streams | ✅      | ✅     | ✅     |

---

## **Real-time Practical Use Case:**

**Task:** From a log file, find failed login attempts, replace the word "Failed" with "LoginFailed", and print only the username column.

**Solution:**

```bash
grep "Failed" auth.log | sed 's/Failed/LoginFailed/' | awk '{print $9}'
```

**Explanation:**

1. `grep "Failed"` → Find lines with "Failed"
2. `sed 's/Failed/LoginFailed/'` → Replace word
3. `awk '{print $9}'` → Extract the 9th column (username)

---

I can also make you a **flow diagram** showing exactly when to use `grep`, `sed`, or `awk` for Linux administration tasks so it sticks in your mind.
Do you want me to make that?
